/**
 *  @file lonate.cpp
 *  @copyright defined in eos/LICENSE.txt
 *  @author    Geujnoo LEE, gjlee@lonate.io
 *  @date       2018-11-06
 *  @version  0.0.1
 */

// account_index accounts;
#include "lonate.hpp"

/**
 *  The purpose of this contract is to implement something like Steem on EOS, this
 *  means this contract defines its own currency, allows people to create offers, vote
 *  on offers, and stake their voting power.
 *
 *  Unlike Steem, the goal is to enable maximum parallelism and enable the currency to
 *  be easily integrated with an exchange contract.
 */

    void lonate::version() {
    eosio::print("YouVote version  0.22"); 
    };


    void lonate::offer(const eosio::name author, const std::string subject, const std::string context, const std::string pictures, const std::string category)
    {
        require_auth(author);

        offers.emplace(get_self(), [&](auto &proffer) {
            proffer.offerid = offers.available_primary_key();
            proffer.author = author;
            proffer.subject = subject;
            proffer.context = context;
        });
    }

    
    void lonate::comment(const eosio::name author, const uint64_t offerid, const std::string context)
    {
        require_auth(author);

        auto cur_post_itr = offers.find(offerid);
        eosio_assert(cur_post_itr != offers.end(), "unknown post");

        // Store new comment
        auto new_comment_itr = comments.emplace(get_self(), [&](auto &comment) {
            comment.commentid = comments.available_primary_key();
            comment.offerid = offerid;
            comment.author = author;
            comment.context = context;
        });
    }


    void lonate::deposit(const eosio::name from, const eosio::asset &quantity)
    {

        eosio_assert(quantity.symbol ==  eosio::symbol("LOTY",4), "only loty token allowed" );
        eosio_assert(quantity.is_valid(), "invalid quantity");
        eosio_assert(quantity.amount > 0, "must deposit positive quantity");

        auto itr = accounts.find(from.value);
        if (itr == accounts.end())
        {
            itr = accounts.emplace(get_self(), [&](auto &acnt) {
                acnt.owner = from.value;
            });
        }
        /*
        action(
            permission_level{from, N(active)},
            N(lonate.token), N(transfer),
            std::make_tuple(from, _self, quantity, std::string("")))
            .send();*/

        accounts.modify(itr, get_self(), [&](auto &acnt) {
            acnt.loty_balance += quantity;
        });
        
    }


    void lonate::donate(const eosio::name from, const uint64_t postid,const eosio::asset &quantity)
    {

        eosio_assert(quantity.symbol ==  eosio::symbol("LOTY",4), "only core token allowed" );
        eosio_assert(quantity.is_valid(), "invalid quantity");
        eosio_assert(quantity.amount > 0, "must deposit positive quantity");

        auto acnt_itr = accounts.find(from.value);
        eosio_assert(acnt_itr != accounts.end(), "unknown account");

        auto post_itr = offers.find( postid );
        eosio_assert(post_itr != offers.end(), "unknown post");

        accounts.modify( acnt_itr, get_self(), [&]( auto& acnt ) {
            eosio_assert( acnt.loty_balance >= quantity, "insufficient balance" );
            acnt.loty_balance -= quantity;
         });

        offers.modify(post_itr, get_self(), [&](auto &post) {
            post.offer_balance += quantity;
        });
        
    }


    void lonate::curate(const eosio::name from, const uint64_t postid)
    {

        auto acnt_itr = accounts.find(from.value);
        eosio_assert(acnt_itr != accounts.end(), "unknown account");

        auto post_itr = offers.find( postid );
        eosio_assert(post_itr != offers.end(), "unknown post");

    if( from == post_itr->author ) {
      //eosio_assert( now() - post.created < days(7), "cannot vote after 7 days" );
      
        offers.modify(post_itr, get_self(), [&](auto &post) {
            post.curated++;
        });

         accounts.modify( acnt_itr, get_self(), [&]( auto& acnt ) {
            acnt.curate_cnt++;
            acnt.last_vote = now();
         });

   } 
  /* else if( context == vote.voter ) {
        offers.modify(post_itr, _self, [&](auto &post) {
            post.curated++;
        });

         accounts.modify( acnt_itr, _self, [&]( auto& acnt ) {
            acnt.curate_cnt++;
            acnt.last_vote = now();
         });

   } else {
      eosio_assert( false, "invalid context for execution of this vote" );
   }*/
        
    }                                            

/* void transfer(uint64_t sender, uint64_t receiver) {

    auto transfer_data = unpack_action_data<st_transfer>();
    if(transfer_data.from == _self || transfer_data.to != _self) {
        return;
    }

    print("\n>>> transfer data quantity >>> ", transfer_data.quantity);

    eosio_assert(transfer_data.quantity.symbol == S(4, "LOTY"),
    "MonsterEOS only accepts EOS for deposits");
    eosio_assert(transfer_data.quantity.is_valid(), "Invalid token transfer");
    eosio_assert(transfer_data.quantity.amount > 0, "Quantity must be positive");

     auto itr = accounts.find(transfer_data.from);
        if (itr == accounts.end())
        {
            itr = accounts.emplace(_self, [&](auto &acnt) {
                acnt.owner = transfer_data.from;
            });
        }
        accounts.modify(itr, 0, [&](auto &acnt) {
            acnt.loty_balance += transfer_data.quantity;
        });
} */

    //@abi action
    /*void deleteacnt(const name to)
    {
        require_auth(to);

        auto itr = accounts.find(to);
        eosio_assert(itr != accounts.end(), "unknown account");
        accounts.erase(itr);

    }

     void deletepost(const uint64_t postid)
    {
        auto itr = offers.find(postid);
        eosio_assert(itr != offers.end(), "unknown post");
        accounts.erase(itr);
    }
    */

 

EOSIO_DISPATCH(lonate, (version)(offer)(comment)(deposit)(donate)(curate))
